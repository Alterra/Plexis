<?php/** * Plexis Content Management System * * @file        System/Core/Logger.php * @copyright   2011-2012, Plexis Dev Team * @license     GNU GPL v3 * @contains    Logger */namespace Core;/** * A log managment class * * @author      Steven Wilson  * @package     Core */class Logger{    /**     * Error level constant     * @var int     */    const ERROR = 1;        /**     * Warning level constant     * @var int     */    const WARN = 2;        /**     * Notice level constant     * @var int     */    const NOTICE = 3;        /**     * Debug level constant     * @var int     */    const DEBUG = 4;        /**     * An array of logger instances for different log files.     * @var Logger[]     */    protected static $logs = array();        /**     * The log files resource stream     * @var resource     */    protected $handle = false;        /**     * The level in which the logger should log     * @var int     */    protected $logLevel = self::DEBUG;        /**     * The log date format     * @var string     */    protected $dataFormat = "Y-m-d H:i:s";        /**     * Constructor     *     * @param string $filepath File path to the log file     * @param string $id The log id (used for retrieving this instance later)     *     * @return void     */    public function __construct($filepath, $id)    {        // constructor        $this->handle = @fopen($filepath, 'a+');                // Make sure the file opened        if($this->handle === false)            throw new \Exception("Unable to open or create log file: ". $filepath);                    self::$logs[$id] = $this;    }        /**     * Sets the minimum log level in order to log messages     *     * @param int $level The minimum log level to record the message     *     * @return void     */    public function setLogLevel($level)    {        if($level > 4 || $level < 0)            return false;                    $this->logLevel = $level;    }        /**     * Writes a line to the log without prepending a status or timestamp      *     * @param string $string The line to write to the log file     *     * @return void     */    public function writeLine($string)    {        fwrite($this->handle, $string . PHP_EOL);        fflush($this->handle);    }        /**     * Writes a line to the log with the severity of ERROR     *     * @param string $string The line to write to the log file     * @param string[] $args An array of replacements in the string (vsprintf)     *     * @return void     */    public function logError($message, $args = false)    {        $this->writeLine($this->format($message, $args, self::ERROR));    }        /**     * Writes a line to the log with the severity of DEBUG     *     * @param string $string The line to write to the log file     * @param string[] $args An array of replacements in the string (vsprintf)     *     * @return void     */    public function logDebug($message, $args = false)    {        // Make sure we want to log this        if($this->logLevel >= self::DEBUG)            $this->writeLine($this->format($message, $args, self::DEBUG));    }        /**     * Writes a line to the log with the severity of WARN     *     * @param string $string The line to write to the log file     * @param string[] $args An array of replacements in the string (vsprintf)     *     * @return void     */    public function logWarning($message, $args = false)    {        // Make sure we want to log this        if($this->logLevel >= self::WARN)            $this->writeLine($this->format($message, $args, self::WARN));    }        /**     * Writes a line to the log with the severity of NOTICE     *     * @param string $string The line to write to the log file     * @param string[] $args An array of replacements in the string (vsprintf)     *     * @return void     */    public function logNotice($message, $args = false)    {        // Make sure we want to log this        if($this->logLevel >= self::NOTICE)            $this->writeLine($this->format($message, $args, self::NOTICE));    }        /**     * Acts as a singleton to fetch a logger object with the given ID     *      * @param string|int $id The id or name that was provided in the logger class'     *   constructor.     *     * @return Logger|bool Returns false if the $id was never set.     */    public static function Get($id)     {        return (isset(self::$logs[$id])) ? self::$logs[$id] : false;    }        /**     * Formats the message with a timestamp, log level, and replace's     * the sprints with the supplied arguments     *      * @param string $message The message to be formated and logged     * @param string[] $args An array of replacements for the $message sprints     * @param int $mode The log level of this message.     *     * @return string Returns the formated message.     */    public function format($message, $args, $mode = false)    {        // Process initial string value        $message = (is_array($args)) ? vsprintf(trim($message), $args) : trim($message);        $start = date($this->dataFormat, time());        switch($mode)        {            case self::ERROR:                return $start .' -- ERROR: '. $message;              case self::DEBUG:                return $start .' -- DEBUG: '. $message;            case self::WARN:                return $start .' -- WARNING: '. $message;            case self::NOTICE:                return $start .' -- NOTICE: '. $message;            default:                return $start .' -- INFO: '. $message;        }    }        /**     * Sets the date format used inside the log file     *      * @param string $format Valid format string for date()     *     * @return void     */    public function setDateFormat($format)    {        $this->dataFormat = $format;    }        /**     * Class Destructor. Closes the file handle.     *     * @return void     */    public function __destruct()    {        if($this->handle)            fclose($this->handle);    }}//EOF